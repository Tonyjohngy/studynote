<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 
        1 自定义指令
        全局注册
        Vue.directive('指令名',{
            inserted(el){
                el.focus()
            }
        })
            
        
        局部注册
        directives{
            '指令名':{
            inserted(el){
                el.focus()
            }
        }
    }

    使用
    v-指令名='指令变量'

    directives: {
    color: {
        el当前  binding传递参数的对象
      inserted (el, binding) {
        el.style.color=binding.value
      },
      一旦更新值就执行代码
      update (el,binding) {
        el.style.color=binding.value 
      }
    }
  }

  自定义指令 - v-loading指令封装
        场景： 实际开发过程中，发送请求需要时间，在请求的数据未回来时，页面会处于空白状态 => 用户体验不好
        需求： 封装一个v-loading指令，实现加载中的效果
        核心思路：

        准备类名Loading，通过伪元素提供遮罩层
        添加或移除类名，实现loading蒙层的添加移除
        利用指令语法，封装v-loading通用指令
        inserted钩子中，binding.value判断指令的值，设置默认状态
        update钩子中，binding.value判断指令的值，更新类名状态
    伪元素所在的容器必须要有默认宽高，不然无法显示


    slot插槽
    1 默认插槽

    作用： 让组件内部的一些结构支持自定义
        场景： 当组件内某一部分结构不确定，用slot占位封装
        使用：

        现在组件内用slot占位
        使用组件时，传入具体标签内容插入

    <slot>我是后备内容</slot>
    2 具名插槽
    需求： 一个组件内有多处结构，需要外部传入标签，进行定制
    多个slot使用name属性区分名字
    <div class="dialog">
    <div class="dialog-header">
      <slot name="head"></slot>
    </div>
    <div class="dialog-content">
      <slot name="content"></slot>
    </div>
    <div class="dialog-footer">
      <slot name="footer"></slot>
    </div>
  </div>
  template配合v-slot:名字 来分发对应标签，可简写为==#名字== 

  <MyDialog>
      <template  v-slot:head><div>我是标题</div></template>
      <template v-slot:content><div>我是内容</div></template>
      <template #footer>
        <button>确认</button>
        <button>取消</button>
      </template>
    </MyDialog>


    插槽 - 作用域插槽
作用域插槽： 定义slot插槽的同时，是可以传值的。给插值上可以绑定数据，将来使用组件时可以用
基本使用步骤：

1 给slot标签，以添加属性的方式传值
<slot :id="item.id" msg="测试文本"></slot>
2 所有添加的属性，都会被收集到一个对象中
{id:3, msg:'测试文本'}
3 在template中，通过 #插槽名"=obj" 接收，默认插槽名为default
<MyTable :data="list">
      <template #default="obj">
        <button @click="del(obj.row.id)">删除</button>
      </template>
</MyTable>

路由
路由就是路径和组件的映射关系
版本对于
vue2 vueRouter 3 vue 3
vue3 vueRouter 4 vue 4


使用步骤
1 
npm add vue-router@3.6.5
2 main.js
import VueRouter from 'vue-router'
Vue.use(VueRouter)
const router = new VueRouter()
new Vue({
	render: h => h(App),
	router:router
}).$mount('#app')

3import Find from './views/Find'
import My from './views/My'
import Friend from './views/Friend'

const router = new VueRouter({
  // route  一条路由规则 { path: 路径, component: 组件 }
  routes: [
    { path: '/find', component: Find },
    { path: '/my', component: My },
    { path: '/friend', component: Friend },
  ]
})
4
<div class="footer_wrap">
      <a href="#/find">发现音乐</a>
      <a href="#/my">我的音乐</a>
      <a href="#/friend">朋友</a>
    </div>
    <div class="top">
      路由出口 → 匹配的组件所展示的位置
      <router-view></router-view>
    </div>




7.组件存放目录问题（组件分类）
组件分类：页面组件 和 复用组件
对应文件夹：
页面组件 - views文件夹 → 配合路由，页面展示
复用组件 - components文件夹 → 封装复用



     -->
</body>
</html>