<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .fa {
            width: 300px;
            height: 300px;
            background-color: antiquewhite;
        }
        .son {
            width: 100px;
            height: 100px;
            background-color: red;
        }
    </style>
</head>
<body>
    <div class="fa">
        <div class="son"></div>
    </div>
    <script>
        const body = document.querySelector('body')
        const fa = document.querySelector('.fa')
        const son = document.querySelector('.son')

        body.addEventListener('click',function(){
            alert('baba')
        })
        fa.addEventListener('click',function(){
            alert('fa')
        })
        son.addEventListener('click',function(e){
            alert('son')
            e.stopPropagation();
        })
        /* 
        8 事件对象
        也是一个对象，里有事件触发的相关信息
        其中的e就是，通常是e,event,ev
        元素.addEventListener('click',function(e){})

        事件对象常用属性
        type 获取当前事件类型
        clientX/clientY 获取光标相对于浏览器可见窗口左上角的位置
        offsetX/offsetY 获取光标相当于当前DOM元素左上角位置
        key用户按下的键值
        trim() 去除空格

        9 环境对象
        变量this代表着当前函数运行所在的环境
        作用：让代码简洁
        谁调用，this就指向谁
        直接调用就是windows
        btn.style.color = 'red' -> this.style.color = 'red'

        10 回调函数
        把一个函数当做参数传递给另一个函数
        匿名函数使用较多
        本质还是函数

        11 事件流
        指的是事件完整执行过程中的流动路径
        捕获、冒泡阶段两个
        document->html->body->div 反过来就是冒泡
        捕获机制
        DOM.addEventListener(事件类型,事件处理函数,是否使用捕获机制) true/false
        默认是false 代表冒泡阶段

        事件冒泡
        触发一个事件会依次触发祖先元素同一个事件

        阻止冒泡
        默认冒泡会影响父级元素
        事件对象.stopPropagation()
        阻止冒泡和捕获

        e.preventDefault)
        阻止默认行为 如提交等

        解绑事件
        直接解绑
        on事件的方式
        对象.onclick = null

        addEventListener方式
        对象.removeEventListener(事件类型,处理函数)

        注意：匿名函数无法解绑

        鼠标经过的区别
        mouseover和mouseout会有冒泡效果
        mouseenter mouseleave没有（推荐）

        注册时间区别
        on
        后面注册事件会覆盖前面（同一个事件）
        解绑就用null覆盖
        都是冒泡执行

        addEventListener
        不会覆盖
        可通过第三个参数去确认冒泡或者捕获阶段的执行

        匿名函数无法解绑

        事件委托
        是利用事件流的特征解决一些开发需求的知识技巧
        不用子元素绑定，直接给父元素绑定，子元素就都有
        原理：触发子元素冒泡父元素触发事件
        通过判断target和tagName获得真实触发的元素
        ul.target 就是li可以就此拿到li对象
        e.target 点击对象
        e.target.tagName 点击对象的标签名

        13 其他事件
        1、加载事件
        外部资源（图片、外联css和js等）加载完毕时触发事件

        应用场景：页面资源处理完做一些事情
                把script写在head中

        方法一：load 整个页面资源windows添加load
        windows.addEventListener('load',function(){})


        页面加载事件
        document添加事件DOMContentLoaded
        无需等待样式表、图片等完全加载

        2、页面滚动事件
        滚动时持续触发的事件
        事件名：scroll 
        给windows或者document添加可检测滚动

        元素.scrollTo(x,y)方法可把内容滚动到指定的坐标


        获取位置
        scrollLeft
        scrollTop
        获取被卷进去的大小
        获取元素内容往左，往上滚出去看不到的距离
        两个值可读，也可赋值不带单位

        document.documentElement.scrollTop获取HTML滚动多少
        3、页面尺寸事件
        resize 浏览器窗口发生变化触发事件
        获取元素可见部分宽高（不包含边框，margin，滚动条等）
        clientWidth clientHeight
        他们是只读属性

        4、元素尺寸与位置
        得到元素在页面的位置
        获取宽高： offsetWidth offsetHeight（内容+padding+border）
        注意：获取的是可视，隐藏的为0
        获取位置： offsetLeft offsetTop 
        获取元素距离自己定位父级的左和上位置 如果没有则文档的左上
        注意：他们是只读属性

        */
    </script>
</body>
</html>